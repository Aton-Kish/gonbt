package gonbt

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"go.uber.org/thriftrw/ptr"
)

func TestSnbtTokenBitmaps_MaskAndToken(t *testing.T) {
	type MaskAndToken struct {
		stringMaskBitmap []uint64
		valueMaskBitmap  []uint64
		tokenBitmaps     map[rune][]uint64
	}

	cases := []struct {
		name string
		snbt *string
		want MaskAndToken
	}{
		{
			name: `Valid Case: Simple`,
			snbt: ptr.String(`{"Hello World": {Name: "Steve"}}`),
			want: MaskAndToken{
				//                                                           }}"evetS" :emaN{ :"dlroW olleH"{
				stringMaskBitmap: []uint64{0b0000000000000000000000000000000000111111000000000011111111111100},
				valueMaskBitmap:  []uint64{0b1111111111111111111111111111111111111111101111110111111111111111},
				tokenBitmaps: map[rune][]uint64{
					//                                      }}"evetS" :emaN{ :"dlroW olleH"{
					'"': {0b0000000000000000000000000000000000100000100000000010000000000010},
					' ': {0b0000000000000000000000000000000000000000010000001000000000000000},
					'{': {0b0000000000000000000000000000000000000000000000010000000000000001},
					'}': {0b0000000000000000000000000000000011000000000000000000000000000000},
					'[': {0b0000000000000000000000000000000000000000000000000000000000000000},
					']': {0b0000000000000000000000000000000000000000000000000000000000000000},
					',': {0b0000000000000000000000000000000000000000000000000000000000000000},
					':': {0b0000000000000000000000000000000000000000001000000100000000000000},
					';': {0b0000000000000000000000000000000000000000000000000000000000000000},
				},
			},
		},
		{
			name: `Valid Case: Compact Simple`,
			snbt: ptr.String(`{"Hello World":{Name:"Steve"}}`),
			want: MaskAndToken{
				//                                                             }}"evetS":emaN{:"dlroW olleH"{
				stringMaskBitmap: []uint64{0b0000000000000000000000000000000000001111110000000011111111111100},
				valueMaskBitmap:  []uint64{0b1111111111111111111111111111111111111111111111111111111111111111},
				tokenBitmaps: map[rune][]uint64{
					//                                        }}"evetS":emaN{:"dlroW olleH"{
					'"': {0b0000000000000000000000000000000000001000001000000010000000000010},
					' ': {0b0000000000000000000000000000000000000000000000000000000000000000},
					'{': {0b0000000000000000000000000000000000000000000000001000000000000001},
					'}': {0b0000000000000000000000000000000000110000000000000000000000000000},
					'[': {0b0000000000000000000000000000000000000000000000000000000000000000},
					']': {0b0000000000000000000000000000000000000000000000000000000000000000},
					',': {0b0000000000000000000000000000000000000000000000000000000000000000},
					':': {0b0000000000000000000000000000000000000000000100000100000000000000},
					';': {0b0000000000000000000000000000000000000000000000000000000000000000},
				},
			},
		},
		{
			name: `Valid Case: Pretty Simple`,
			snbt: ptr.String(`{
    "Hello World": {
        Name: "Steve"
    }
}`),
			want: MaskAndToken{
				//                                       }\n}    \n"evetS" :emaN        \n{ :"dlroW olleH"    \n{
				stringMaskBitmap: []uint64{0b0000000000000_000000_0111111000000000000000_000011111111111100000_00},
				valueMaskBitmap:  []uint64{0b1111111111111_010000_0111111101111100000000_010111111111111110000_01},
				tokenBitmaps: map[rune][]uint64{
					//                  }\n}    \n"evetS" :emaN        \n{ :"dlroW olleH"    \n{
					'"': {0b0000000000000_000000_0100000100000000000000_000010000000000010000_00},
					' ': {0b0000000000000_101111_1000000010000011111111_101000000000000001111_10},
					'{': {0b0000000000000_000000_0000000000000000000000_010000000000000000000_01},
					'}': {0b0000000000001_010000_0000000000000000000000_000000000000000000000_00},
					'[': {0b0000000000000_000000_0000000000000000000000_000000000000000000000_00},
					']': {0b0000000000000_000000_0000000000000000000000_000000000000000000000_00},
					',': {0b0000000000000_000000_0000000000000000000000_000000000000000000000_00},
					':': {0b0000000000000_000000_0000000001000000000000_000100000000000000000_00},
					';': {0b0000000000000_000000_0000000000000000000000_000000000000000000000_00},
				},
			},
		},
		{
			name: `Valid Case: Compact Tag Check`,
			snbt: ptr.String(`{Compound:{ByteArray:[B;0b,1b],Compound:{String:"World"},List:[123b],Short:12345s,String:"Hello"}}`),
			want: MaskAndToken{
				//                           1[:tsiL,}"dlroW":gnirtS{:dnuopmoC,]b1,b0;B[:yarrAetyB{:dnuopmoC{                                  }}"olleH":gnirtS,s54321:trohS,]b32
				stringMaskBitmap: []uint64{0b0000000001111110000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000011111100000000000000000000000000},
				valueMaskBitmap:  []uint64{0b1111111111111111111111111111111111111111111111111111111111111111, 0b1111111111111111111111111111111111111111111111111111111111111111},
				tokenBitmaps: map[rune][]uint64{
					//      1[:tsiL,}"dlroW":gnirtS{:dnuopmoC,]b1,b0;B[:yarrAetyB{:dnuopmoC{                                  }}"olleH":gnirtS,s54321:trohS,]b32
					'"': {0b0000000001000001000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000010000010000000000000000000000000},
					' ': {0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000},
					'{': {0b0000000000000000000000010000000000000000000000000000010000000001, 0b0000000000000000000000000000000000000000000000000000000000000000},
					'}': {0b0000000010000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000001100000000000000000000000000000000},
					'[': {0b0100000000000000000000000000000000000000001000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000},
					']': {0b0000000000000000000000000000000000100000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000001000},
					',': {0b0000000100000000000000000000000001000100000000000000000000000000, 0b0000000000000000000000000000000000000000000000100000000000010000},
					':': {0b0010000000000000100000001000000000000000000100000000001000000000, 0b0000000000000000000000000000000000000001000000000000010000000000},
					';': {0b0000000000000000000000000000000000000000100000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000},
				},
			},
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			stbm := NewSnbtTokenBitmaps(*c.snbt)
			stbm.SetTokenBitmaps()
			stbm.SetMaskBitmaps()

			assert.Equal(t, c.want.stringMaskBitmap, stbm.StringMaskBitmap)
			assert.Equal(t, c.want.valueMaskBitmap, stbm.ValueMaskBitmap)
			assert.Equal(t, c.want.tokenBitmaps, stbm.TokenBitmaps)
		})
	}
}

func TestSnbtTokenBitmaps_Compact(t *testing.T) {
	type compactTestCase struct {
		name string
		snbt *string
		want *string
	}

	cases := []compactTestCase{}

	for _, v := range NBTValidTestCases {
		dc := compactTestCase{
			name: v.name,
			snbt: v.snbt,
			want: v.compactSnbt,
		}
		cases = append(cases, dc)

		pc := compactTestCase{
			name: v.name,
			snbt: v.prettySnbt,
			want: v.compactSnbt,
		}
		cases = append(cases, pc)
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			stbm := NewSnbtTokenBitmaps(*c.snbt)
			stbm.SetTokenBitmaps()
			stbm.SetMaskBitmaps()

			cstbm := stbm.Compact()
			assert.Equal(t, *c.want, string(cstbm.Raw))
		})
	}
}

func TestRemoveRightmost(t *testing.T) {
	cases := []struct {
		name string
		bit  uint64
		want uint64
	}{
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000000_00000000,
		},
		{
			name: `Valid Case: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111`,
			bit:  0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
			want: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111110,
		},
		{
			name: `Invalid Case: rightmost does not exist`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := removeRightmost(c.bit)
			assert.Equal(t, c.want, actual)
		})
	}
}

func TestExtractRightmost(t *testing.T) {
	cases := []struct {
		name string
		bit  uint64
		want uint64
	}{
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
		},
		{
			name: `Valid Case: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111`,
			bit:  0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
		},
		{
			name: `Invalid Case: rightmost does not exist`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := extractRightmost(c.bit)
			assert.Equal(t, c.want, actual)
		})
	}
}

func TestSmearRightmost(t *testing.T) {
	cases := []struct {
		name string
		bit  uint64
		want uint64
	}{
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_11111111,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_11111111,
		},
		{
			name: `Valid Case: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111`,
			bit:  0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
			want: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
		},
		{
			name: `Invalid Case: rightmost does not exist`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
			want: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := smearRightmost(c.bit)
			assert.Equal(t, c.want, actual)
		})
	}
}

func TestRightmostIndex(t *testing.T) {
	cases := []struct {
		name string
		bit  uint64
		want int
	}{
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
			want: 0,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
			want: 8,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000,
			want: 8,
		},
		{
			name: `Valid Case: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111`,
			bit:  0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
			want: 0,
		},
		{
			name: `Invalid Case: rightmost does not exist`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
			want: 0,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := rightmostIndex(c.bit)
			assert.Equal(t, c.want, actual)
		})
	}
}

func TestPopCount(t *testing.T) {
	cases := []struct {
		name string
		bit  uint64
		want int
	}{
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
			want: 0,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
			want: 1,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
			want: 1,
		},
		{
			name: `Valid Case: 0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000`,
			bit:  0b00000000_00000000_00000000_00000000_00000000_00000001_00000001_00000000,
			want: 2,
		},
		{
			name: `Valid Case: 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111`,
			bit:  0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111,
			want: 64,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := popCount(c.bit)
			assert.Equal(t, c.want, actual)
		})
	}
}

func TestBitmapCount(t *testing.T) {
	cases := []struct {
		name   string
		bitmap []uint64
		want   int
	}{
		{
			name:   `Valid Case: []uint64{0x0000000000000000}`,
			bitmap: []uint64{0x0000000000000000},
			want:   0,
		},
		{
			name:   `Valid Case: []uint64{0x0000000000000000, 0x0000000000000001}`,
			bitmap: []uint64{0x0000000000000000, 0x0000000000000001},
			want:   1,
		},
		{
			name:   `Valid Case: []uint64{0x0000000000000001, 0x0000000000000100}`,
			bitmap: []uint64{0x0000000000000001, 0x0000000000000100},
			want:   2,
		},
		{
			name:   `Valid Case: []uint64{0x0000000000000100, 0x0000000000010100}`,
			bitmap: []uint64{0x0000000000000100, 0x0000000000010100},
			want:   3,
		},
		{
			name:   `Valid Case: []uint64{0x0000000000010100, 0xFFFFFFFFFFFFFFFF}`,
			bitmap: []uint64{0x0000000000010100, 0xFFFFFFFFFFFFFFFF},
			want:   66,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			actual := bitmapCount(c.bitmap)
			assert.Equal(t, c.want, actual)
		})
	}
}
